{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file://G%3A/PORTFOLIO/portfolio/src/lib/redis.ts"],"sourcesContent":["import Redis, { RedisOptions } from 'ioredis';\r\n\r\n/**\r\n * Redis connection URL from environment variables.\r\n * @throws {Error} If REDIS_URL is not set.\r\n */\r\nconst redisUrl = process.env.REDIS_URL;\r\n\r\nif (!redisUrl) {\r\n    throw new Error('Redis configuration error: REDIS_URL is required');\r\n}\r\n\r\n/**\r\n * Redis client configuration options.\r\n * Includes:\r\n * - Automatic reconnection with exponential backoff (max 2s delay)\r\n * - 20 max retries per request\r\n * - 5s connection timeout\r\n * - 10s keepalive\r\n * - TLS support for 'rediss://' URLs\r\n */\r\nconst redisOptions: RedisOptions = {\r\n    retryStrategy: (times) => Math.min(times * 50, 2000),\r\n    maxRetriesPerRequest: 20,\r\n    connectTimeout: 5000,\r\n    keepAlive: 10000,\r\n    tls: redisUrl.startsWith('rediss://') ? { rejectUnauthorized: false } : undefined,\r\n};\r\n\r\n/**\r\n * Redis client instance with:\r\n * - Pre-configured connection options\r\n * - Event listeners for connection lifecycle\r\n * - Graceful shutdown on SIGTERM\r\n *\r\n * @event connect - Successful TCP connection\r\n * @event ready - Ready to accept commands\r\n * @event error - Connection error\r\n * @event close - Connection closed\r\n * @event reconnecting - Reconnection attempt\r\n */\r\nexport const redis = new Redis(redisUrl, redisOptions);\r\n\r\n// Connection event listeners\r\nredis\r\n    .on('connect', () => console.log('✅ Redis connected'))\r\n    .on('ready', () => console.log('🚀 Redis ready'))\r\n    .on('error', (err) => console.error('❌ Redis error:', err))\r\n    .on('close', () => console.warn('🔌 Redis connection closed'))\r\n    .on('reconnecting', () => console.log('🔁 Redis reconnecting...'));\r\n\r\n/**\r\n * Graceful shutdown handler.\r\n * Closes Redis connection on SIGTERM signal.\r\n */\r\nprocess.on('SIGTERM', () => {\r\n    redis.quit().then(() => console.log('Redis gracefully terminated'));\r\n});\r\n"],"names":[],"mappings":";;;AAAA;;AAEA;;;CAGC,GACD,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS;AAEtC,IAAI,CAAC,UAAU;IACX,MAAM,IAAI,MAAM;AACpB;AAEA;;;;;;;;CAQC,GACD,MAAM,eAA6B;IAC/B,eAAe,CAAC,QAAU,KAAK,GAAG,CAAC,QAAQ,IAAI;IAC/C,sBAAsB;IACtB,gBAAgB;IAChB,WAAW;IACX,KAAK,SAAS,UAAU,CAAC,eAAe;QAAE,oBAAoB;IAAM,IAAI;AAC5E;AAcO,MAAM,QAAQ,IAAI,2IAAA,CAAA,UAAK,CAAC,UAAU;AAEzC,6BAA6B;AAC7B,MACK,EAAE,CAAC,WAAW,IAAM,QAAQ,GAAG,CAAC,sBAChC,EAAE,CAAC,SAAS,IAAM,QAAQ,GAAG,CAAC,mBAC9B,EAAE,CAAC,SAAS,CAAC,MAAQ,QAAQ,KAAK,CAAC,kBAAkB,MACrD,EAAE,CAAC,SAAS,IAAM,QAAQ,IAAI,CAAC,+BAC/B,EAAE,CAAC,gBAAgB,IAAM,QAAQ,GAAG,CAAC;AAE1C;;;CAGC,GACD,QAAQ,EAAE,CAAC,WAAW;IAClB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAM,QAAQ,GAAG,CAAC;AACxC","debugId":null}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file://G%3A/PORTFOLIO/portfolio/src/lib/validateContactToken.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { redis } from './redis';\r\nimport jwt from 'jsonwebtoken';\r\nimport { z } from 'zod';\r\n\r\n/**\r\n * Schema for the JWT token payload.\r\n * Expects a `jti` (JWT ID) field as a string.\r\n */\r\nexport const TokenSchema = z.object({\r\n    jti: z.string(),\r\n});\r\n\r\nexport type ContactTokenPayload = z.infer<typeof TokenSchema>;\r\n\r\n/**\r\n * Custom error class for token validation failures.\r\n * Includes:\r\n * - `message`: Human-readable error description.\r\n * - `code`: Machine-readable error code (e.g., 'MISSING_TOKEN').\r\n * - `statusCode`: Suggested HTTP status code (default: 401).\r\n */\r\nexport class TokenValidationError extends Error {\r\n    constructor(\r\n        message: string,\r\n        public readonly code: string,\r\n        public readonly statusCode: number = 401\r\n    ) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n/**\r\n * Validates a one-time contact token from the request headers.\r\n *\r\n * ### Flow:\r\n * 1. Extracts token from `Authorization: Bearer <token>` header.\r\n * 2. Verifies JWT signature and expiration using `JWT_SECRET`.\r\n * 3. Checks if token exists in Redis (preventing reuse).\r\n * 4. Deletes the token from Redis on success.\r\n *\r\n * ### Error Cases:\r\n * - `MISSING_TOKEN` (401): No token provided.\r\n * - `CONFIG_ERROR` (500): Missing `JWT_SECRET` env variable.\r\n * - `TOKEN_EXPIRED` (401): JWT is expired.\r\n * - `INVALID_TOKEN` (401): JWT is malformed or Redis lookup failed.\r\n * - `INVALID_PAYLOAD` (401): Token payload doesn't match `TokenSchema`.\r\n * - `VALIDATION_ERROR` (500): Unexpected error (e.g., Redis failure).\r\n *\r\n * @example\r\n * ```ts\r\n * try {\r\n *   await validateContactToken(request);\r\n *   // Proceed with contact logic...\r\n * } catch (err) {\r\n *   if (err instanceof TokenValidationError) {\r\n *     return new Response(err.message, { status: err.statusCode });\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport async function validateContactToken(req: NextRequest): Promise<void> {\r\n    // 1. Extract token\r\n    const authHeader = req.headers.get('authorization');\r\n    const token = authHeader?.startsWith('Bearer ') ? authHeader.slice(7) : null;\r\n\r\n    if (!token) {\r\n        throw new TokenValidationError('Token is missing', 'MISSING_TOKEN', 401);\r\n    }\r\n\r\n    // 2. Check config\r\n    const jwtSecret = process.env.JWT_SECRET;\r\n    if (!jwtSecret) {\r\n        throw new TokenValidationError('JWT_SECRET is not set', 'CONFIG_ERROR', 500);\r\n    }\r\n\r\n    try {\r\n        // 3. Verify JWT\r\n        const decoded = TokenSchema.parse(\r\n            jwt.verify(token, jwtSecret)\r\n        );\r\n\r\n        // 4. Check Redis\r\n        const key = `contact_token:${encodeURIComponent(decoded.jti)}`;\r\n        const exists = await redis.get(key);\r\n        if (!exists) {\r\n            throw new TokenValidationError('Token expired or invalid', 'INVALID_TOKEN', 401);\r\n        }\r\n\r\n        // 5. Invalidate token\r\n        await redis.del(key).catch(err => {\r\n            console.error('Failed to delete token from Redis:', err, { key });\r\n        });\r\n\r\n    } catch (error) {\r\n        // Handle known errors\r\n        if (error instanceof jwt.TokenExpiredError) {\r\n            throw new TokenValidationError('Token expired', 'TOKEN_EXPIRED', 401);\r\n        }\r\n\r\n        if (error instanceof jwt.JsonWebTokenError) {\r\n            throw new TokenValidationError('Invalid token', 'INVALID_TOKEN', 401);\r\n        }\r\n\r\n        if (error instanceof z.ZodError) {\r\n            console.error('Token payload validation failed:', error.errors);\r\n            throw new TokenValidationError('Invalid token payload', 'INVALID_PAYLOAD', 401);\r\n        }\r\n\r\n        // Fallback\r\n        console.error('Unexpected error:', error);\r\n        throw new TokenValidationError('Token validation failed', 'VALIDATION_ERROR', 500);\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA;;;;AAMO,MAAM,cAAc,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChC,KAAK,sIAAA,CAAA,IAAC,CAAC,MAAM;AACjB;AAWO,MAAM,6BAA6B;;;IACtC,YACI,OAAe,EACf,AAAgB,IAAY,EAC5B,AAAgB,aAAqB,GAAG,CAC1C;QACE,KAAK,CAAC,eAHU,OAAA,WACA,aAAA;IAGpB;AACJ;AA+BO,eAAe,qBAAqB,GAAgB;IACvD,mBAAmB;IACnB,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;IACnC,MAAM,QAAQ,YAAY,WAAW,aAAa,WAAW,KAAK,CAAC,KAAK;IAExE,IAAI,CAAC,OAAO;QACR,MAAM,IAAI,qBAAqB,oBAAoB,iBAAiB;IACxE;IAEA,kBAAkB;IAClB,MAAM,YAAY,QAAQ,GAAG,CAAC,UAAU;IACxC,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,qBAAqB,yBAAyB,gBAAgB;IAC5E;IAEA,IAAI;QACA,gBAAgB;QAChB,MAAM,UAAU,YAAY,KAAK,CAC7B,uIAAA,CAAA,UAAG,CAAC,MAAM,CAAC,OAAO;QAGtB,iBAAiB;QACjB,MAAM,MAAM,CAAC,cAAc,EAAE,mBAAmB,QAAQ,GAAG,GAAG;QAC9D,MAAM,SAAS,MAAM,qHAAA,CAAA,QAAK,CAAC,GAAG,CAAC;QAC/B,IAAI,CAAC,QAAQ;YACT,MAAM,IAAI,qBAAqB,4BAA4B,iBAAiB;QAChF;QAEA,sBAAsB;QACtB,MAAM,qHAAA,CAAA,QAAK,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,CAAA;YACvB,QAAQ,KAAK,CAAC,sCAAsC,KAAK;gBAAE;YAAI;QACnE;IAEJ,EAAE,OAAO,OAAO;QACZ,sBAAsB;QACtB,IAAI,iBAAiB,uIAAA,CAAA,UAAG,CAAC,iBAAiB,EAAE;YACxC,MAAM,IAAI,qBAAqB,iBAAiB,iBAAiB;QACrE;QAEA,IAAI,iBAAiB,uIAAA,CAAA,UAAG,CAAC,iBAAiB,EAAE;YACxC,MAAM,IAAI,qBAAqB,iBAAiB,iBAAiB;QACrE;QAEA,IAAI,iBAAiB,sIAAA,CAAA,IAAC,CAAC,QAAQ,EAAE;YAC7B,QAAQ,KAAK,CAAC,oCAAoC,MAAM,MAAM;YAC9D,MAAM,IAAI,qBAAqB,yBAAyB,mBAAmB;QAC/E;QAEA,WAAW;QACX,QAAQ,KAAK,CAAC,qBAAqB;QACnC,MAAM,IAAI,qBAAqB,2BAA2B,oBAAoB;IAClF;AACJ","debugId":null}},
    {"offset": {"line": 279, "column": 0}, "map": {"version":3,"sources":["file://G%3A/PORTFOLIO/portfolio/src/lib/middleware/withContactValidation.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { validateContactToken, TokenValidationError } from '../validateContactToken';\r\n\r\n/**\r\n * HOC для валидации контактного токена\r\n * @param handler Основной обработчик маршрута\r\n * @returns Обработчик с проверкой токена\r\n * @throws {TokenValidationError} 401 при ошибке валидации\r\n */\r\nexport function withContactValidation(\r\n    handler: (req: NextRequest) => Promise<NextResponse>\r\n) {\r\n    return async (req: NextRequest) => {\r\n        try {\r\n            console.log(`[Auth] Validating contact token for ${req.url}`);\r\n            await validateContactToken(req);\r\n            return await handler(req);\r\n        } catch (error) {\r\n            if (error instanceof TokenValidationError) {\r\n                console.warn(`[Auth] Validation failed: ${error.code}`);\r\n                return NextResponse.json(\r\n                    { error: error.message, code: error.code },\r\n                    { status: error.statusCode }\r\n                );\r\n            }\r\n            console.error('[Auth] Unexpected error:', error);\r\n            return NextResponse.json(\r\n                { error: 'Internal Server Error' },\r\n                { status: 500 }\r\n            );\r\n        }\r\n    };\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAQO,SAAS,sBACZ,OAAoD;IAEpD,OAAO,OAAO;QACV,IAAI;YACA,QAAQ,GAAG,CAAC,CAAC,oCAAoC,EAAE,IAAI,GAAG,EAAE;YAC5D,MAAM,CAAA,GAAA,oIAAA,CAAA,uBAAoB,AAAD,EAAE;YAC3B,OAAO,MAAM,QAAQ;QACzB,EAAE,OAAO,OAAO;YACZ,IAAI,iBAAiB,oIAAA,CAAA,uBAAoB,EAAE;gBACvC,QAAQ,IAAI,CAAC,CAAC,0BAA0B,EAAE,MAAM,IAAI,EAAE;gBACtD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;oBAAE,OAAO,MAAM,OAAO;oBAAE,MAAM,MAAM,IAAI;gBAAC,GACzC;oBAAE,QAAQ,MAAM,UAAU;gBAAC;YAEnC;YACA,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAEtB;IACJ;AACJ","debugId":null}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":["file://G%3A/PORTFOLIO/portfolio/src/app/api/send-message/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { withContactValidation } from '@/lib/middleware/withContactValidation';\r\nimport { Resend } from 'resend';\r\n\r\nconst resend = new Resend(process.env.RESEND_API_KEY);\r\n\r\nasync function handler(req: NextRequest) {\r\n    const data = await req.json();\r\n    const { name, email, message } = data;\r\n    console.log(`Portfolio <${process.env.FROM_EMAIL}>`)\r\n    try {\r\n        const emailResponse = await resend.emails.send({\r\n            from: `Portfolio <${process.env.FROM_EMAIL}>`,\r\n            to: process.env.TO_EMAIL as string,\r\n            subject: 'Новое сообщение с лендинга',\r\n            html: `\r\n        <h1>Новое сообщение</h1>\r\n        <p><strong>Имя:</strong> ${name}</p>\r\n        <p><strong>Email:</strong> ${email}</p>\r\n        <p><strong>Сообщение:</strong> ${message}</p>\r\n      `,\r\n        });\r\n\r\n        if (emailResponse.error) {\r\n            return NextResponse.json(\r\n                { success: false, message: 'Ошибка при отправке письма' },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        return NextResponse.json(\r\n            { success: true, message: 'Письмо успешно отправлено' },\r\n            { status: 200 }\r\n        );\r\n    } catch  {\r\n        return NextResponse.json(\r\n            { success: false, message: 'Ошибка сервера' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport const POST = withContactValidation(handler);\r\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAEA,MAAM,SAAS,IAAI,0IAAA,CAAA,SAAM,CAAC,QAAQ,GAAG,CAAC,cAAc;AAEpD,eAAe,QAAQ,GAAgB;IACnC,MAAM,OAAO,MAAM,IAAI,IAAI;IAC3B,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG;IACjC,QAAQ,GAAG,CAAC,CAAC,WAAW,EAAE,QAAQ,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;IACnD,IAAI;QACA,MAAM,gBAAgB,MAAM,OAAO,MAAM,CAAC,IAAI,CAAC;YAC3C,MAAM,CAAC,WAAW,EAAE,QAAQ,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;YAC7C,IAAI,QAAQ,GAAG,CAAC,QAAQ;YACxB,SAAS;YACT,MAAM,CAAC;;iCAEc,EAAE,KAAK;mCACL,EAAE,MAAM;uCACJ,EAAE,QAAQ;MAC3C,CAAC;QACC;QAEA,IAAI,cAAc,KAAK,EAAE;YACrB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,SAAS;gBAAO,SAAS;YAA6B,GACxD;gBAAE,QAAQ;YAAI;QAEtB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;YAAE,SAAS;YAAM,SAAS;QAA4B,GACtD;YAAE,QAAQ;QAAI;IAEtB,EAAE,OAAO;QACL,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;YAAE,SAAS;YAAO,SAAS;QAAiB,GAC5C;YAAE,QAAQ;QAAI;IAEtB;AACJ;AAEO,MAAM,OAAO,CAAA,GAAA,mJAAA,CAAA,wBAAqB,AAAD,EAAE","debugId":null}}]
}